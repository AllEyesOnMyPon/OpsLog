#!/usr/bin/env bash
set -euo pipefail

# Defaults
METHOD="POST"
URL="${ENTRYPOINT_URL:-http://127.0.0.1:8081/ingest}"
API_KEY="${LOGOPS_API_KEY:-demo-pub-1}"
SECRET="${LOGOPS_SECRET:-demo-priv-1}"

DATA=""            # inline body
BODY_FILE=""       # file path
USE_NONCE=1        # default: include X-Nonce (AuthGW zwykle tego wymaga)
TS=""              # exact timestamp (ISO Z)
TS_OFFSET=""       # e.g. +30s, -2m

EXTRA_HEADERS=()
CURL_EXTRA_ARGS=()
VERBOSE=0
ECHO_HEADERS=0

usage() {
  cat <<'USAGE'
hmac_curl.sh — HMAC-signing wrapper for LogOps AuthGW

Usage:
  tools/hmac_curl.sh [options] [-- ...extra curl args]

Options:
  -u, --url URL            Target URL (default: $ENTRYPOINT_URL or http://127.0.0.1:8081/ingest)
  -X, --method M           HTTP method (default: POST)
  -k, --key KEY            X-Api-Key (default: $LOGOPS_API_KEY or demo-pub-1)
  -s, --secret S           HMAC secret  (default: $LOGOPS_SECRET or demo-priv-1)
  -d, --data STR           Inline request body
  -f, --file PATH          Request body from file (sent as --data-binary @PATH)
  -H "Header: V"           Extra header (repeatable)
      --nonce              Force adding X-Nonce (auto)   [default]
      --no-nonce           Do NOT add X-Nonce
      --ts ISO             Use exact timestamp (ISO Z)
      --ts-offset SPEC     Time offset (e.g. +30s, -2m, +1h)
      --echo-headers       Print only: -H "K: V" -H "K: V" ... and exit
  -v, --verbose            Verbose curl
  -h, --help               Show this help

Notes:
 - If method is GET and no body is provided, request is sent without a body.
 - Default Content-Type: application/json is added only when a body is sent
   AND you didn't override it with -H.
 - HMAC headers are generated by tools/sign_hmac.py (same canonical as emitters).

Examples:
  tools/hmac_curl.sh --data '[]'
  tools/hmac_curl.sh -f /tmp/body.csv -H 'Content-Type: text/csv'
  tools/hmac_curl.sh -X GET --url http://127.0.0.1:8081/_debug/hdrs --echo-headers
USAGE
}

# Parse args
while [[ $# -gt 0 ]]; do
  case "$1" in
    -u|--url) URL="$2"; shift 2 ;;
    -X|--method) METHOD="$2"; shift 2 ;;
    -k|--key) API_KEY="$2"; shift 2 ;;
    -s|--secret) SECRET="$2"; shift 2 ;;
    -d|--data) DATA="$2"; BODY_FILE=""; shift 2 ;;
    -f|--file|--body-file) BODY_FILE="$2"; DATA=""; shift 2 ;;
    -H) EXTRA_HEADERS+=("$2"); shift 2 ;;
    --nonce) USE_NONCE=1; shift ;;
    --no-nonce) USE_NONCE=0; shift ;;
    --ts) TS="$2"; shift 2 ;;
    --ts-offset) TS_OFFSET="$2"; shift 2 ;;
    --echo-headers) ECHO_HEADERS=1; shift ;;
    -v|--verbose) VERBOSE=1; shift ;;
    -h|--help) usage; exit 0 ;;
    --) shift; CURL_EXTRA_ARGS+=("$@"); break ;;
    *) CURL_EXTRA_ARGS+=("$1"); shift ;;
  esac
done

# Build signer args
SIGN_ARGS=("$API_KEY" "$SECRET" "$METHOD" "$URL")
TMP_BODY=""
cleanup() {
  if [[ -n "${TMP_BODY:-}" && -f "${TMP_BODY:-}" ]]; then rm -f "$TMP_BODY"; fi
}
trap cleanup EXIT

if [[ -n "$BODY_FILE" ]]; then
  SIGN_ARGS+=("" "--body-file" "$BODY_FILE")
else
  # pass inline body (empty string ok)
  SIGN_ARGS+=("${DATA:-}")
fi

# optional signer flags
if [[ $USE_NONCE -eq 1 ]]; then SIGN_ARGS+=("--nonce"); fi
if [[ -n "$TS" ]]; then SIGN_ARGS+=("--ts" "$TS"); fi
if [[ -n "$TS_OFFSET" ]]; then SIGN_ARGS+=("--ts-offset" "$TS_OFFSET"); fi

# Call signer (multi-line "K: V")
# (bez --one-per-line żeby prościej sparsować)
mapfile -t RAW_HDRS < <( python3 tools/sign_hmac.py "${SIGN_ARGS[@]}" )

# Convert to curl -H args
HDR_ARGS=()
for line in "${RAW_HDRS[@]}"; do
  # Expect "Key: Value"
  [[ -z "$line" ]] && continue
  HDR_ARGS+=(-H "$line")
done

# Echo requested headers and exit (formatted as: -H "K: V" -H "K: V"...)
if [[ $ECHO_HEADERS -eq 1 ]]; then
  FIRST=1
  for h in "${HDR_ARGS[@]}"; do
    if [[ $FIRST -eq 1 ]]; then
      printf '%s' "$h"
      FIRST=0
    else
      printf ' %s' "$h"
    fi
  done
  printf '\n'
  exit 0
fi

# Build curl command
CURL_ARGS=(-sS -X "$METHOD" "$URL")
[[ $VERBOSE -eq 1 ]] && CURL_ARGS=(-v "${CURL_ARGS[@]}")

# Determine if user already set Content-Type (case-insensitive)
HAS_CT=0
for h in "${EXTRA_HEADERS[@]}"; do
  if [[ "${h,,}" =~ ^content-type: ]]; then HAS_CT=1; break; fi
done

# Add default Content-Type only if body is present AND not overridden
HAS_BODY=0
if [[ -n "$BODY_FILE" || -n "$DATA" ]]; then HAS_BODY=1; fi
if [[ $METHOD != "GET" && $HAS_BODY -eq 1 && $HAS_CT -eq 0 ]]; then
  EXTRA_HEADERS=("Content-Type: application/json" "${EXTRA_HEADERS[@]}")
fi

# Add signed headers first (X-*)
CURL_ARGS+=("${HDR_ARGS[@]}")
# Then user-provided headers (to allow overriding e.g. Content-Type)
for h in "${EXTRA_HEADERS[@]}"; do
  CURL_ARGS+=(-H "$h")
done

# Attach body if provided
if [[ -n "$BODY_FILE" ]]; then
  CURL_ARGS+=(--data-binary "@${BODY_FILE}")
elif [[ -n "$DATA" ]]; then
  CURL_ARGS+=(--data "$DATA")
else
  # No body for GET (or any method) if not provided
  :
fi

# Extra curl args (timeouts, --http1.1, etc.)
CURL_ARGS+=("${CURL_EXTRA_ARGS[@]}")

# Execute
exec curl "${CURL_ARGS[@]}"
